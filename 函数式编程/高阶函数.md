#### 函数式编程
* 一种抽象程度很高的编程范式纯粹的函数式编程语言编写的函数没有变量，任意一个函数，只要输入是确定的，输出也就确定了，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。
* 函数式编程的一个特点是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。

##### 高阶函数（Higher-order function)
*  变量可以指向函数
* 函数名也是变量：函数名就是指向函数的变量
* 传入函数：函数可以当做变量传入函数
* 一个函数可以接收另一个函数作为参数，这种函数就称为高阶函数


### map/reduce
#### map
* Python 内建的函数`map()`，map接收两个参数，一个`函数`，一个`iteratable`，`map`将传入的函数依次作用到序列的每个元素，并把结果作为新的`iterator`返回。  

		L = [1, 2, 3, 4, 5, 6]
		def f(x):
    		return x*x
		print map(f, L)	
		[1, 4, 9, 16, 25, 36]	
		
#### reduce
* `reduce`把一个函数作用在一个序列上，这个函数必须接收两个参数，`reduce`把每次调用返回的结果和序列中的下一个元素进行累计计算。

		reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2),x3), x4)
* 使用reduce需要导入`from functools import reduce`


### filter
* Python内建的`filter()`函数用于过滤序列。
* `filter()`和`map()`差不多，都是接收一个函数和一个Iterable作为参数，不同是`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`True`还是`False`决定保留还是丢弃该元素。
* `filter()`的作用是从一个序列中筛选出符合条件的元素。由于`filter()`使用了惰性计算，所以只有在取`filter()`结果的时候，才会真正筛选并每次返回下一个筛选出的元素。

#### sorted
* Python内置的`sorted()`函数就可以对list进行排序。
* `sorted()`函数也是一个高阶函数，可以接收一个`key`函数来实现自定义的排序
* `sorted()`是一个高阶函数，用`sorted()`排序的关键在于实现一个映射函数。


		nonlocal 为Python3之后新加属性
		global 和 nonlocal的区别：global是指使用全局定义，nonlocal是使用上一层定义的，不一定是全局的

#### 返回函数
* 一个函数可以返回一个计算结果，也可以返回一个函数
* 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会改变的变量

#### 匿名函数
* 关键字`lambda`表示匿名函数，冒号前面的变量表示`函数参数`
* 匿名函数有个限制，只能有一个表达式，不用写`return`， 返回值就是该表达式的结果
* 使用匿名函数的好处是，不用写函数名，不用担心函数名冲突。匿名函数也是一个函数对象，可以将匿名函数赋值给一个变量，再利用变量来调用该函数


#### 装饰器（decorator）
* 在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。
* PYthon的decorator可以用函数实现，也可以用类实现
* decorator可以增强函数的功能，定义起来虽然有些复杂
* 装饰器使用`@`+作为装饰的类，将`@`放在需要装饰的类上面，定义装饰器时需要传入一个函数，这个函数是被装饰的函数的函数名，返回的也是一个函数。  
* 装饰器中使用@functools.wraps(func)放在作为装饰器的函数中，func是传入的函数名

#### 偏函数
* 当函数的参数个数太多，需要简化时，使用functools.partial 可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单
* 调用时使用functools.partial(原函数名, 原函数的参数)

